\documentclass[letterpaper]{article}
% \usepackage{natbib}
\usepackage[utf8]{inputenc}
% \usepackage[margin=3.5cm]{geometry}
% \usepackage{listings}
% \usepackage{adjustbox}
% \usepackage{xcolor}
% \usepackage{verbatim}
% \usepackage{graphicx}%images
% \usepackage{fancyhdr}%for headers and footers
% \usepackage{adjustbox}
% \usepackage{verbatim}
% \usepackage{listings}
% \usepackage{fancyhdr}
% \usepackage{multirow}
% \usepackage{amsmath}
% \usepackage{mathtools}

% \usepackage{array}
% \usepackage{subcaption}
% \usepackage{float}
% \usepackage{csvsimple}
% \usepackage{filecontents}
% \usepackage{lscape}
% \usepackage{afterpage}
% \usepackage{hyperref}
% \usepackage{inconsolata}
% \usepackage{color}

\usepackage{mathpazo}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{todonotes}


% \usepackage{draftwatermark}
% \SetWatermarkText{Draft}
% \SetWatermarkScale{2}

% Math function

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\tuple}{\langle}{\rangle}
\newcommand{\darrow}{\, \downarrow \!\!}
\newcommand{\uarrow}{\, \uparrow \!\!}

% Theorems styles

\theoremstyle{definition}
\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{example}{Example}[subsection]

% \newenvironment{conditions}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}={}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
%
%   \newenvironment{conditions_bis}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}\in{}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
% \definecolor{pblue}{rgb}{0.13,0.13,1}
% \definecolor{pgreen}{rgb}{0,0.5,0}
% \definecolor{pred}{rgb}{0.9,0,0}
% \definecolor{pgrey}{rgb}{0.46,0.45,0.48}
%
% \lstset{language=Python,
%   showspaces=false,
%   numbers=left,
%   showtabs=false,
%   breaklines=true,
%   showstringspaces=false,
%   breakatwhitespace=true,
%   commentstyle=\color{pgreen},
%   keywordstyle=\color{pblue},
%   stringstyle=\color{pred},
%   basicstyle=\ttfamily,
%   moredelim=[il][\textcolor{pgrey}]{$ $},
%   moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
% }
%
%
%
% \hypersetup{
%     colorlinks,
%     citecolor=black,
%     filecolor=black,
%     linkcolor=black,
%     urlcolor=black
% }
%
%
% % ------ HEADERS AND FOOTERS -----------
% % \lhead{INFO-F403}
% % \rhead{Project Report - Part 1}
% %\pagestyle{fancy}
% % \rfoot{\thepage}
% %\cfoot{}
% %\lfoot{Academic Year 2017-18}
%
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} %newcommand for cover page


\begin{document}

\begin{titlepage}

\begin{center}


\textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
\textsc{\Large D\'epartment d'Informatique}\\[1.5cm]

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.3\textwidth]{images/ulblogo.jpg}~\\[1cm]

\textsc{
\large MEMO-F-403 \\
\Large  Preparatory work for the master thesis
 \\[1cm]}
% Title
\HRule \\[0.7cm]

{ \huge \bfseries Implementing data structures for
Partially Ordered Set \\[0.7cm] }

\HRule \\[2cm]

% Author and supervisor
\noindent
\begin{center} \large

%\emph{Author:}\\
\Large Hakim \textsc{Boulahya}\\
\end{center}
\begin{center} \large

\emph{Supervised by} \\
\Large Emmanuel \textsc{Filiot} \\

\end{center}

\vfill
% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}


% \title{Implementing data structures for \\ Partially Ordered Set}
% \author{Hakim Boulahya}
%


% \maketitle

\newpage

\tableofcontents

\newpage

\listoftodos

\newpage

\section{Introduction}

\todo{In the paper, should I use We or I, or nothing ?}

\paragraph{}

Automata theory is used in various field in computer science and has shown
to be an interesting way to resolve important problems,
such as synthesis of computer systems
or the universality problem. It has been proved that those problems are
PSPACE-complete \cite{ant_univers}.
\todo{cite the original papers of those problems (w/ complexity)}

\todo{Talk about the problems, complexity and alternative (Safra vs antichain)}
More efficient algorithms to resolve those problems have been implemented
using antichain based-algorithms. Antichains are data structures that allow
to represent a partially ordered set, in a more compact way.

The goal of this preparatory work is to motivate the interest that
are made in the antichains data structure, and why we need an efficient
implementation.
It also defines the desired objectives
and propose and state-of-the-art of the existing implementation.

\paragraph{Motivation}

An example that highlights the use of antichains in automata theory is
the universality problem. It is the problem that for an automaton
\texttt{A}, is the language of \texttt{A} equivalent to the language
of all the words on the alphabet, that is, is $L(A) = \Sigma^*$.
The language of \texttt{A} is universal if and only if the language
of the complementary of \texttt{A} accepts no words, that is,
$L(A) = \Sigma^*$ if and only if $L(\bar{A}) = \emptyset$.
The only way to compute the complementary of \texttt{A} is to first
determinise it, which is hard. Now if $L(\bar{A})$ is the empty set,
\todo{We have to define complementary with det. computation to understand
why we use set of state}
it means that there is no set of states that for which there exists a word
such that this word is accepted by $\bar{A}$. A function can be
defined to check the existence of such sets. Let the function
\todo{Define F bar, final state of A bar}
\todo{EAcc function def is not correct, how to correctly formulate it ?}
\todo{EAcc, set or function ?}
$EAcc^A(w) = X
= \{ P \subseteq Q, P' \subseteq Q, P' \cap \bar{F} = \emptyset
| \exists w \in \Sigma^* s.t. P \xrightarrow{w} P'\}$.
The goal is to show that if there exists
no set of states $P$ such that $P \cap F = \emptyset$ i.e.
$X = \emptyset$, then it is shown that $L(\bar{A}) = \emptyset$, therefore
$A$ is universal. The difficulty of the problem arise at the computation
of $X$. Checking intersection between the accepting states set and all
the subsets is costly.
\todo{Costly vs expensive vs complexe vs hard etc..}
For a subset $P \subseteq Q$, for all subsets $p$ such that $p \subseteq P$,
it is known that, computing the work $w$ starting from $p$ or $P$, will lead
to the same final state. Therefore it is more interesting to compute
the maximal sets $\ceil{X}$, which correspond to an antichain of set of
states that are $\subseteq$-uncomparable.

In the antichain algorithms paper
\cite{AC_universality}, the algorithm proposed follow an idea equivalent
by using game theory. The universality problem is reduce to
a two-player reachability game, which can be done in polynomial time.
The objective of the game is for the protagonist to establish that
the automaton $A$ is not universal. To this end, the protagonist will
provide a word, a letter at a time, and find a strategy that try
to show that $A$ ends in a rejecting state.
The protagonist only has a strategy to win the game if and only if $A$ is
not universal.

\todo{Include that UP is a problem important because verif-related problem
reduce to it}

\paragraph{Objective}

this thesis is to provide an efficient implementation of different
data structures that allow to compactly
represent partially ordered sets, specifically antichains and pseudo-antichains.
The first step is to implement in Java, classes that will be provided to
the \texttt{Owl} library \cite{owl}.
\texttt{Owl} is a LTL to deterministic automata translations tool-set written
in \texttt{Java}. A second step will be to implement
antichain-based algorithms using the new antichains implementation and
study the performance.

\paragraph{Related work}

\todo{Include difference betweens BDDs and Antichains}


\texttt{AaPAL} is a generic
library is a that was implemented in the frame of
Aaron Bohy's PhD thesis \cite{bohy_phd}
to provide an antichain library. It is implemented in \texttt{C}.
\todo{How are antichains implemented in Acacia+ ?
Is it AaPAL or another impl. ?}

An implementation of antichains in \texttt{Java} have been done
by De Causmaecker and De Wannemacker in \cite{causemaecker1}. The algorithms
to find the ninth Dedekind number uses antichains and they needed to
implement a representation of antichains.
To improve efficiency and performances, Hoedts in \cite{hoedt} has extended
\cite{causemaecker1} antichains implementation by using bit sequence
instead of tree reprensentation.

\todo{Discuss impl. specifics etc in chapter Implementation}
\todo{What operations are implemented in those papers ?}
\todo{What domain (of sets) is is used in those papers ?}
\todo{Research other possible related works}

\paragraph{Structure of the work}

This work is the introduction to next year thesis. Therefore
the content concern only the prelimenaries, the goal is to
properly define the subject and existing implementation.
In Section \ref{data_structures}, we formally define antichains,
and give examples of such data structures. In Section \ref{impl},
we cite and summarize the work that has been done by the community
for antichains implementation. In \ref{conclusion}, we propose
an overview of next year work and possibilities.



\section{Data Structures}

In this section, we will provide formal definitions of the data
structures that we will implement. We recall the notion of binary relations
and important propreties of such relations.
We then define partially ordered set, totally order set and closed set.
Finally we give a formal definition for antichains and pseudo-antichains.

\paragraph{}

The definitions and examples for this section are based on \cite{bohy_phd}.


\subsection{Binary relations}

\paragraph{}

A binary relation for an arbitrary set $S$ is
a set of pair $R \subseteq S \times S$.
There are five important properties: reflexitivity, transitivity,
symmetry, antisymmetry and total.

\paragraph{}

A relation $R$ on $S$ is said to be:

\begin{itemize}
    \item Reflexive:
    iff $\forall s \in S$ it holds that $(s, s) \in R$
    \item Transitive:
    iff $\forall s_1, s_2, s_3 \in S$,
    if ($s_1, s_2) \in R$ and $(s_2, s_3) \in R$
    then it holds that $(s_1, s_3) \in R$
    \item Symmetric: iff $(s_1, s_2) \in R$ then $(s_2, s_1) \in R$.
    \item Antisymmetric: iff $(s_1, s_2) \in R$
    and $(s_2, s_1) \in R$ then $s_1 = s_2$
    \item Total: iff $\forall s_1, s_2 \in S$ then $(s_1, s_2) \in R$
    or $(s_2, s_1) \in R$

\end{itemize}

\paragraph{Orders}

A \textit{partial order} is a binary relation that is \textit{reflexive},
\textit{transitive} and \textit{antisymmetric}. We note a
partial order relation by $R$.
We note $s_1 R  s_2$ to show the belonging of
a binary relation to a partial order, which is equivalent
to $(s_1, s_2) \in \ R$.
A \textit{total order} is a partial order that is \textit{total}.

\begin{example}

For example, the comparison of natural numbers is a partial order.
Let $\leq$ be a binary relation on $\mathbb{N}$
such that $\leq \ \subseteq \mathbb{N}^2$. The binary relation is defined
following the usual semantic of the symbol, i.e. $n_1 \leq n_2$ if and
only if $n_1$ is smaller or equal to $n_2$.
Based on this, $\leq$ is a partial order. It is
reflexive, transitive and antisymmetric.
The binary relation $\leq$ on natural numbers is actually a total
order since all the natural numbers can be compared against each other.

\end{example}

\begin{example}
    % the inclusion $\subseteq$ is a partial order on
    % $2^{\mathbb{N}}$,
    % the power set of natural numbers.

A more interesting example is the set inclusion.

\end{exameple}

\subsection{Partially ordered set}

\paragraph{}

An arbitrary set $S$ associated with a partial order $\preceq$
is called a \textit{partially ordered set} or \textit{poset}.
It is denoted by the pair $\langle S, \preceq \rangle$.

\paragraph{Comparable}

Let $s_1, s_2 \in S$ and $\tuple{S, \preceq}$ a poset.
The two elementes $s_1$ and $s_2$ are called \textit{comparable} if either
$s_1 \preceq s_2$ or $s_2 \preceq s_1$. If neither of those two comparaisons
are correct, then $s_1$ and $s_2$ are called \textit{uncomparable}.


\paragraph{Bounds} Let $\tuple{S, \preceq}$ a partially ordered set.
We denote the \textit{greatest lower bound} of the two elements $s_1, s_2 \in S$
by $s_1 \sqcap s_2 \in S$.
The greatest lower bound is defined as follow:
$s_1 \sqcap s_2 \preceq s_1$,
$s_1 \sqcap s_2 \preceq s_2$ and for all $s' \in S$ we have that
if $s' \preceq s_1$ and $s' \preceq s_2$ then $s' \preceq s_1 \sqcap s_2$.

\todo{Include definition of least upper bound}

\paragraph{Lattices} A \textit{lower semilattice} is a poset
$\tuple{S, \preceq}$ where for all pair of elements $s_1, s_2 \in S$,
we have that the greatest lower bound $s_1 \sqcap s_2$ exists.

\subsection{Antichains}

\subsubsection{Closed sets}

\paragraph{}


A closed set is a set $L \subseteq S$
of a lower semilattice $\langle S, \preceq \rangle$
where $\forall \ell \in L$ we have that $\forall s \in S$ such that
$s \preceq \ell$, then $s \in L$.

Note that for two closed sets $L_1, L_2 \subseteq S$, we have that
$L_1 \cup L_2$ and $L_1 \cap L_2$ are also closed sets,
but $L_1 \setminus L_2$ does not result necessarily to a closed set.

\paragraph{Maximal/minimal elements} We denote by $\ceil{L}$
the set of maximal elements of a closed set $L$ which
\todo{Meaning of | vs . vs : in set definition ?}
correspond to $\ceil{L} =
\{ \ell \in L | \forall \ell' \in L : \ell \preceq \ell'
 \Rightarrow \ell = \ell' \}$. Alternatively, to represent the set of minimal
 elements, the noation $\floor{L}$ is used which has the following semantic
$\floor{L} = \{ \ell \in L | \forall \ell' \in L :  \ell' \preceq \ell
 \Rightarrow \ell = \ell' \}$.


\paragraph{Closure} A \textit{lower closure} of a set $L$ on $S$
noted $\darrow L$ is the set of all elements of $S$ that are
\textit{smaller or equal} to an element of $L$ i.e.
$\darrow L = \{ s \in S \ | \ \exists \ell \in L \cdot s \preceq \ell\}$.
Note that for a closed set $L$ we have that $\darrow L = L$.



\paragraph{Antichain}

An antichain of a poset $\tuple{S, \preceq}$
is a set $\alpha \subseteq S$ where all element of $\alpha$
are uncomparable with respect to the partial order $\preceq$.
Antichains allow to represent closed set in a more compact way.
For a closed set $L \subseteq S$ we can retrieve all elements of $L$ by using
the antichain $\alpha = \ceil{L}$. With respect
to the definition of the lower closure we have that $\darrow \alpha = L$.

\subsection{Operations on antichains}

\todo{Cite original paper, FJR11 from Bohy' phd}



\begin{proposition}

\label{antichains_ops}

Let $\alpha_1, \alpha_2 \subseteq S$ two antichains and $s \in S$:

\begin{itemize}
    \item $s \in \darrow \alpha_1$
    iff $\exists a \in \alpha_1$ such that $\preceq a$
    \item $\darrow \alpha_1 \subseteq \darrow \alpha_2$
    iff $\forall a_1 \in \alpha_1,
    \exists a_2 \in \alpha_2$ such that $a_1 \preceq a_2$
    \item $ \darrow \alpha_1 \ \cup \darrow \alpha_2 =
    \darrow \ceil{\alpha_1 \cup \alpha_2}$
    \item $\darrow \alpha_1 \ \cap \darrow \alpha_2 =
    \darrow \ceil{\alpha_1 \sqcap \alpha_2}$

\todo{Give complete definition for interesection}

\end{itemize}

\end{proposition}



% \subsection{Pseudo-antichains}
%
% \paragraph{}
%
% An antichain is a subset of $S$ that allow to represent in a compact way
% a set $L \subseteq S$ that is not necessarily closed.

\section{Implementation}

\paragraph{}

Java already provide built-in implementation for \texttt{Set}.
\todo{Includes limitation of Java built-in and different possible solution
for antichains found on stack overflow and others}

\paragraph{}

In this thesis we are more interested in partially ordered sets as
totally ordered sets are already implemented
in\texttt{Java} built-in
\texttt{SortedSet}.

\subsection{Summary of objectives}


\paragraph{}


The main focus of the thesis is to be able to provide an efficient
implementation of antichains and pseudo-antichains in \texttt{Java}.
The first step is to provide an interface for the different operations that
can be applied to antichains. We then give a description of the implementation.
Antichains provide a way to represent
in a compact way partially ordered set that are closed. Pseudo-antichains
are an extension of antichains and provide a compact way to represent
partially ordered sets. Pseudo-antichains does not specifically require
closed set.

Our goal is to find a way to not keep all the closure all
element of the antichain in memory, but be able to retrieve those elements
or check the belonging of a closure element from the uncomparable elements
of the antichain.

\subsection{Existing implementation}

\subsubsection{AaPAL}

Bohy's \textbf{A}ntichain
\textbf{a}nd \textbf{P}seudo-\textbf{A}ntichain \textbf{L}ibrary \cite{aapal}
is an open-source \texttt{C} library for the manipulation
of antichains and pseudo-antichains data structures.


\paragraph{Antichain representation}

An antichain is represented by a \texttt{struct}, containing as attributes
the size of the antichain, and the uncomparable elements of the antichains,
as a list. The list is manipulated using the \texttt{GSList} object
from the \texttt{glib} library. To allow modularity, the type of the elements
is \texttt{void}.

\paragraph{Operations}

The operations implemented in \texttt{AaPAL}
are described in this section.
An interesting remark is that most of the complexity is given as a paramater
to the functions. For example the function to compare two elements in
an antichain is given as a parameter. It means that the complexity to define
the domain of the antichain, must be implemented in the compare function.

Operations such as creating an antichain,
adding an element to
an antichain, checking emptiness or cloning an antichain are implemented
in \texttt{AaPAL}. In addition to that

create
add elem
clone

interesection
Union

compare 2 antichains

containing element
closure size



\subsubsection{ABD}

\subsubsection{Hoedt's ABD modifications}
\todo{Referring to \cite{hoedt}}
\todo{Is actually \cite{hoedt} what we what to do, and if not, what will
be the differences ?}



\subsection{Difficulties}

\todo{What is the difference beetween domain, univers and set ?}

One of the difficulties is to define the domain of the elements that
the antichains should work on. In \texttt{AaPAL} the all complexity
is implemented in the \texttt{compare\_elements} that must be given
to the library functions. It that case, all the complexity of the
must be implemented by the user to define the domain of the antichains.

\subsubsection{Tree vs Bitarray representations}


\subsection{Possible solutions}

In the case of the domain specifications, a good approach could be to
provide an interface/abstract class to the users, to let them provide
their own implementation. In addition to that, usual domain such a
natural numbers or others well known domain used, could be directly implemented
in the library.


\subsection{New implementation}


\section{Next year}

\label{conclusion}


\subsection{Possible extensions}


As we mainly focus on efficiency, it could be interesting to use a \texttt{C}
implementation such as \texttt{AaPAL},
and provide bindings to \texttt{Java}. We could try
this method as an alternative to a pure \texttt{Java} implementation and
compare performances.


\todo{Fill-in bib correctly!}

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
