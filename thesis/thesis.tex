\documentclass[letterpaper]{memoir}
% \usepackage{natbib}
\usepackage[utf8]{inputenc}
% \usepackage[margin=3.5cm]{geometry}
% \usepackage{listings}
% \usepackage{adjustbox}
% \usepackage{xcolor}
% \usepackage{verbatim}
% \usepackage{graphicx}%images
% \usepackage{fancyhdr}%for headers and footers
% \usepackage{adjustbox}
% \usepackage{verbatim}
% \usepackage{listings}
% \usepackage{fancyhdr}
% \usepackage{multirow}
% \usepackage{amsmath}
% \usepackage{mathtools}

% \usepackage{array}
% \usepackage{mathpazo}
% \usepackage{subcaption}
% \usepackage{float}
% \usepackage{csvsimple}
% \usepackage{filecontents}
% \usepackage{lscape}
% \usepackage{afterpage}
% \usepackage{hyperref}
% \usepackage{inconsolata}
% \usepackage{color}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{todonotes}



% Math function

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\tuple}{\langle}{\rangle}
% \newenvironment{conditions}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}={}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
%
%   \newenvironment{conditions_bis}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}\in{}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
% \definecolor{pblue}{rgb}{0.13,0.13,1}
% \definecolor{pgreen}{rgb}{0,0.5,0}
% \definecolor{pred}{rgb}{0.9,0,0}
% \definecolor{pgrey}{rgb}{0.46,0.45,0.48}
%
% \lstset{language=Python,
%   showspaces=false,
%   numbers=left,
%   showtabs=false,
%   breaklines=true,
%   showstringspaces=false,
%   breakatwhitespace=true,
%   commentstyle=\color{pgreen},
%   keywordstyle=\color{pblue},
%   stringstyle=\color{pred},
%   basicstyle=\ttfamily,
%   moredelim=[il][\textcolor{pgrey}]{$ $},
%   moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
% }
%
%
%
% \hypersetup{
%     colorlinks,
%     citecolor=black,
%     filecolor=black,
%     linkcolor=black,
%     urlcolor=black
% }
%
%
% % ------ HEADERS AND FOOTERS -----------
% % \lhead{INFO-F403}
% % \rhead{Project Report - Part 1}
% %\pagestyle{fancy}
% % \rfoot{\thepage}
% %\cfoot{}
% %\lfoot{Academic Year 2017-18}
%
% \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} %newcommand for cover page


%\begin{titlepage}

% \begin{center}

%
% \textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
% \textsc{\Large D\'epartment d'Informatique}\\[1.5cm]
%
% % Upper part of the page. The '~' is needed because \\
% % only works if a paragraph has started.
% \includegraphics[width=0.3\textwidth]{images/ulblogo.jpg}~\\[1cm]
%
% \textsc{
% \large MEMO-F-403 \\
% \Large  Preparatory work for the master thesis
%  \\[1cm]}
% % Title
% \HRule \\[0.7cm]
%
% { \huge \bfseries Thesis - draft \#1 \\[0.7cm] }
%
% \HRule \\[2cm]
%
% % Author and supervisor
% \noindent
% \begin{center} \large
%
% \emph{Author:}\\
% \Large Hakim \textsc{Boulahya}\\
% \end{center}
% \begin{center} \large
%
% \emph{Supervisor:} \\
% Emmanuel \textsc{Filiot} \\

% \end{center}
%
% \vfill
%
% % Bottom of the page
% {\large \today}
%
% \end{center}
%\end{titlepage}


\title{(Pre)Thesis draft}
\author{Hakim Boulahya}

\begin{document}

\maketitle

\tableofcontents

\listoftodos

\chapter{Introduction}


\section{Motivation}

\paragraph{}


Automata theory is used in various field in computer science and has shown
to be an interesting way to resolve important problems,
such as synthesis of computer systems
or the universality problem. It has been proved that those problems are
PSPACE-complete \cite{bsp, ant_univers}.
\todo{cite the original papers of those problems (w/ complexity)}

\todo{Talk about the problems, complexity and alternative (Safra vs antichain)}
More efficient algorithms to resolve those problems have been implemented
using antichain based-algorithms. Antichains are data structures that allow
to represent a partially ordered set, in a more compact way.

\paragraph{}


The goal of this thesis is to provide an efficient implementation of different
data structures that allow to compactly
represent partially ordered sets, specifically antichains and pseudo-antichains.
The first step is to implement in Java, classes that will be provided to
the \texttt{Owl} library \cite{owl}.
\texttt{Owl} is a LTL to deterministic automata translations tool-set written
in \texttt{Java}. A second step will be to implement
antichain-based algorithms using the new antichains implementation and
study the performance.


\section{Related work}

\paragraph{}

\texttt{AaPAL} library is a that was implemented in the context of
Aaron Bohy's PhD thesis \cite{bohy_phd}
to provide an antichain library. It is implemented in \texttt{C}.

\paragraph{}

\todo{This small paragraph is an open discussion}
As we mainly focus on efficiency, it could be interesting to use a \texttt{C}
implementation such as \texttt{AaPAL},
and provide bindings to \texttt{Java}. We could try
this method as an alternative to a pure \texttt{Java} implementation and
compare performances.

\chapter{Data Structures}

In this section, we will provide formal definitions of the data
structures that we will implement. We recall the notion of binary relations
and important propreties of such relations.
We then define partially ordered set, totally order set and closed set.
Finally we give a formal definition for antichains and pseudo-antichains.

\paragraph{}

The definitions and examples for this section are based on \cite{bohy_phd}.


\section{Binary relations}

\paragraph{}

A binary relation for an arbitrary set $S$ is
a set of pair $R \subseteq S \times S$.
There are five important properties: reflexitivity, transitivity,
symmetry, antisymmetry and total.

\paragraph{}

A relation $R$ on $S$ is said to be:

\begin{itemize}
    \item Reflexive:
    iff $\forall s \in S$ it holds that $(s, s) \in R$
    \item Transitive:
    iff $\forall s_1, s_2, s_3 \in S$,
    if ($s_1, s_2) \in R$ and $(s_2, s_3) \in R$
    then it holds that $(s_1, s_3) \in R$
    \item Symmetric: iff $(s_1, s_2) \in R$ then $(s_2, s_1) \in R$.
    \item Antisymmetric: iff $(s_1, s_2) \in R$
    and $(s_2, s_1) \in R$ then $s_1 = s_2$
    \item Total: iff $\forall s_1, s_2 \in S$ then $(s_1, s_2) \in R$
    or $(s_2, s_1) \in R$\todo{is this Total def correct ?}

\end{itemize}

\paragraph{Orders}

A \textit{partial order} is a binary relation that is \textit{reflexive},
\textit{transitive} and \textit{antisymmetric}. We note a
partial order relation by $R$.
We note $s_1 R  s_2$ to show the belonging of
a binary relation to a partial order, which is equivalent
to $(s_1, s_2) \in \ R$.
A \textit{total order} is a partial order that is \textit{total}.

\section{Partially ordered set}

\paragraph{}

An arbitrary set $S$ associated with a partial order $\preceq$
is called a \textit{partially ordered set} or \textit{poset}.
It is denoted by the pair $\langle S, \preceq \rangle$.

\paragraph{Comparable}

Let $s_1, s_2 \in S$ and $\tuple{S, \preceq}$ a poset.
The two elementes $s_1$ and $s_2$ are called \textit{comparable} if either
$s_1 \preceq s_2$ or $s_2 \preceq s_1$. If neither of those two comparaisons
are correct, then $s_1$ and $s_2$ are called \textit{uncomparable}.


\paragraph{Bounds} Let $\tuple{S, \preceq}$ a partially ordered set.
We denote the \textit{greatest lower bound} of the two elements $s_1, s_2 \in S$
by $s_1 \sqcap s_2 \in S$.
The greatest lower bound is defined as follow:
$s_1 \sqcap s_2 \preceq s_1$,
$s_1 \sqcap s_2 \preceq s_2$ and for all $s' \in S$ we have that
if $s' \preceq s_1$ and $s' \preceq s_2$ then $s' \preceq s_1 \sqcap s_2$.

\todo{Include definition of least upper bound}

\paragraph{Lattices} A \textit{lower semilattice} is a poset
$\tuple{S, \preceq}$ where for all pair of elements $s_1, s_2 \in S$,
we have that the greatest lower bound $s_1 \sqcap s_2$ exists.

\section{Antichains and pseudo-antichains}

\subsection{Closed sets}

\paragraph{}


A closed set is a set $L \subseteq S$
of a lower semilattice $\langle S, \preceq \rangle$
where $\forall l \in L$ we have that $\forall s \in S$ such that
$s \preceq l$, then $s \in L$.

Note that for two closed sets $L_1, L_2 \subseteq S$, we have that
$L_1 \cup L_2$ and $L_1 \cap L_2$ are also closed sets,
but $L_1 \setminus \L_2$ does not result necessarily to a closed set.

\paragraph{Maximal/minimal elements} We denote by $\ceil{L}$
the set of maximal elements of a closed set $L$ which
\todo{Meaning of | vs . vs : in set definition ?}
correspond to $\ceil{L} = \{ l \in L | \forall l' \in L :  l \preceq l'
 \Rightarrow l = l' \}$. Alternatively, to represent the set of minimal
 elements, the noation $\floor{L}$ is used which has the following semantic
$\floor{L} = \{ l \in L | \forall l' \in L :  l' \preceq l
 \Rightarrow l = l' \}$.


\paragraph{Closure} A \textit{lower closure} of a set $L$ on $S$
noted $\downarrow L$ is the set of all elements of $S$ that are
\textit{smaller or equal} to an element of $L$ i.e.
$\downarrow L = \{ s \in S \ | \ \exists l \in L \cdot s \preceq l\}$.
Note that for a closed set $L$ we have that $\downarrow L = L$.


\subsection{Antichains}

\paragraph{}

An antichain of a poset $\tuple{S, \preceq}$
is a set $\alpha \subseteq S$ where all element of $\alpha$
are uncomparable with respect to the partial order $\preceq$.
Antichains allow to represent closed set in a more compact way.
For a closed set $L \subseteq S$ we can retrieve all elements of $L$ by using
the antichain $\alpha = \ceil{L}$. With respect
to the definition of the lower closure we have that $\downarrow \alpha = L$.

\paragraph{Operations}

Let $\alpha_1, \alpha_2 \subseteq S$ two antichains and $s \in S$:

\begin{itemize}
    \item $s \in \downarrow \alpha_1$
    iff $\exists a \in \alpha_1$ s.t. $\preceq a$
    \item $\downarrow \alpha_1 \subseteq \downarrow \alpha_2$
    iff $\forall a_1 \in \alpha_1,
    \exists a_2 \in \alpha_2$ s.t. $a_1 \preceq a_2$
    \item $ \downarrow \alpha_1 \cup \downarrow \alpha_2 =
    \downarrow \ceil{\alpha_1 \cup \alpha_2}$
    \item $\downarrow \alpha_1 \ \cap \downarrow \alpha_2 =
    \downarrow \ceil{\alpha_1 \sqcap \alpha_2}$
\end{itemize}

% \subsection{Pseudo-antichains}
%
% \paragraph{}
%
% An antichain is a subset of $S$ that allow to represent in a compact way
% a set $L \subseteq S$ that is not necessarily closed.

\chapter{Implementation}

\paragraph{}

Java already provide built-in implementation for \texttt{Set}.
\todo{Includes limitation of Java built-in and different possible solution
for antichains found on stack overflow}

\paragraph{}


\todo{Is this total order affirmation correct ?}
In this thesis we are more interested in partial ordered sets as
total order sets can be easily implemented as lists.

\section{Summary of objectives}

\paragraph{}


The main focus of the thesis is to be able to provide an efficient
implementation of antichains and pseudo-antichains in \texttt{Java}.
The first step is to provide an interface for the different operations that
can be applied to antichains. We then give a description of the implementation.
Antichains provide a way to represent
in a compact way partially ordered set that are closed. Pseudo-antichains
are an extension of antichains and provide a compact way to represent
partially ordered sets. Pseudo-antichains does not specifically require
closed set.



\section{Existing implementation}




\todo{Everything below is a fast/draft notes}

\section{Motivation and objective}

For the moment, the implementation to represent the data strutures in
 Acacia+
is specifically designed for a specific set. The idea is to propose a new
library implementation to provide an API that will implement important
data structures that are used in syntesis algorithms.

\paragraph{}

The objective of the thesis is to provide an efficient library to represent
antichain data structures and implement different operation. An final
goal is to be able to use this library within Aaron/Acacia.


* Impl. datastrcture antichain in Java
* Theoritacal context: synthesis,
unverversality and automata theory known problem
* Practical context: Owl, Acacia+ and AaPAL

* Why interesting: More efficient than CTL symbolic with BDD

\subsection{Related Work}

* Java Built-in IMPL
* AaPAL
* Stackoverflow
* Acacia ?

\section{Notions}

\subsection{Model checking and synthesis}

Model checking is the process to verify a software model with
specifications.

Synthesis is the process to derive the system from specifications.

\cite{bohyphd}

\cite{ltl_rea}
\subsection{Data structures}

\paragraph{Binary Decision Diagram}

\paragraph{Antichain}

BDD vs antichain

Antichain vs pseudo-antichain

\section{Questions}

* Maastricht library ? \cite{acacia} \cite{aapal}
* How to references ?
* What to impl (about operations) ?

* Is implementing LTL Rea. or Universality a final goal of the thesis ?

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
