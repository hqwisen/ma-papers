\documentclass[letterpaper]{memoir}
% \usepackage{natbib}
\usepackage[utf8]{inputenc}
% \usepackage[margin=3.5cm]{geometry}
% \usepackage{listings}
% \usepackage{adjustbox}
% \usepackage{xcolor}
% \usepackage{verbatim}
% \usepackage{graphicx}%images
% \usepackage{fancyhdr}%for headers and footers
% \usepackage{adjustbox}
% \usepackage{verbatim}
% \usepackage{listings}
% \usepackage{fancyhdr}
% \usepackage{multirow}
% \usepackage{amsmath}
% \usepackage{mathtools}

% \usepackage{array}
% \usepackage{mathpazo}
% \usepackage{subcaption}
% \usepackage{float}
% \usepackage{csvsimple}
% \usepackage{filecontents}
% \usepackage{lscape}
% \usepackage{afterpage}
% \usepackage{hyperref}
% \usepackage{inconsolata}
% \usepackage{color}

\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{todonotes}



% Math function

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\tuple}{\langle}{\rangle}
\newcommand{\darrow}{\, \downarrow \!\!}
\newcommand{\uarrow}{\, \uparrow \!\!}

% Theorems styles

\newtheorem{proposition}{Proposition}

% \newenvironment{conditions}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}={}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
%
%   \newenvironment{conditions_bis}
%   {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}
%   {>{$}l<{$} @{${}\in{}$} l}}
%   {\end{tabular}\par\vspace{\belowdisplayskip}}
%
% \definecolor{pblue}{rgb}{0.13,0.13,1}
% \definecolor{pgreen}{rgb}{0,0.5,0}
% \definecolor{pred}{rgb}{0.9,0,0}
% \definecolor{pgrey}{rgb}{0.46,0.45,0.48}
%
% \lstset{language=Python,
%   showspaces=false,
%   numbers=left,
%   showtabs=false,
%   breaklines=true,
%   showstringspaces=false,
%   breakatwhitespace=true,
%   commentstyle=\color{pgreen},
%   keywordstyle=\color{pblue},
%   stringstyle=\color{pred},
%   basicstyle=\ttfamily,
%   moredelim=[il][\textcolor{pgrey}]{$ $},
%   moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
% }
%
%
%
% \hypersetup{
%     colorlinks,
%     citecolor=black,
%     filecolor=black,
%     linkcolor=black,
%     urlcolor=black
% }
%
%
% % ------ HEADERS AND FOOTERS -----------
% % \lhead{INFO-F403}
% % \rhead{Project Report - Part 1}
% %\pagestyle{fancy}
% % \rfoot{\thepage}
% %\cfoot{}
% %\lfoot{Academic Year 2017-18}
%
% \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} %newcommand for cover page


%\begin{titlepage}

% \begin{center}

%
% \textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
% \textsc{\Large D\'epartment d'Informatique}\\[1.5cm]
%
% % Upper part of the page. The '~' is needed because \\
% % only works if a paragraph has started.
% \includegraphics[width=0.3\textwidth]{images/ulblogo.jpg}~\\[1cm]
%
% \textsc{
% \large MEMO-F-403 \\
% \Large  Preparatory work for the master thesis
%  \\[1cm]}
% % Title
% \HRule \\[0.7cm]
%
% { \huge \bfseries Thesis - draft \#1 \\[0.7cm] }
%
% \HRule \\[2cm]
%
% % Author and supervisor
% \noindent
% \begin{center} \large
%
% \emph{Author:}\\
% \Large Hakim \textsc{Boulahya}\\
% \end{center}
% \begin{center} \large
%
% \emph{Supervisor:} \\
% Emmanuel \textsc{Filiot} \\

% \end{center}
%
% \vfill
%
% % Bottom of the page
% {\large \today}
%
% \end{center}
%\end{titlepage}


\title{(Pre)Thesis draft}
\author{Hakim Boulahya}

\begin{document}

\maketitle

\tableofcontents

\listoftodos

\chapter{Introduction}


\section{Motivation}

\paragraph{}


Automata theory is used in various field in computer science and has shown
to be an interesting way to resolve important problems,
such as synthesis of computer systems
or the universality problem. It has been proved that those problems are
PSPACE-complete \cite{ant_univers}.
\todo{cite the original papers of those problems (w/ complexity)}

\todo{Talk about the problems, complexity and alternative (Safra vs antichain)}
More efficient algorithms to resolve those problems have been implemented
using antichain based-algorithms. Antichains are data structures that allow
to represent a partially ordered set, in a more compact way.

\paragraph{}


The goal of this thesis is to provide an efficient implementation of different
data structures that allow to compactly
represent partially ordered sets, specifically antichains and pseudo-antichains.
The first step is to implement in Java, classes that will be provided to
the \texttt{Owl} library \cite{owl}.
\texttt{Owl} is a LTL to deterministic automata translations tool-set written
in \texttt{Java}. A second step will be to implement
antichain-based algorithms using the new antichains implementation and
study the performance.


\section{Related work}

\todo{Include difference betweens BDDs and Antichains}

\paragraph{}

\texttt{AaPAL} is a generic
library is a that was implemented in the frame of
Aaron Bohy's PhD thesis \cite{bohy_phd}
to provide an antichain library. It is implemented in \texttt{C}.
\todo{How are antichains implemented in Acacia+ ?
Is it AaPAL or another impl. ?}


\paragraph{}

An implementation of antichains in \texttt{Java} have been done
by De Causmaecker and De Wannemacker in \cite{causemaecker1}. The algorithms
to find the ninth Dedekind number uses antichains and they needed to
implement a representation of antichains.
To improve efficiency and performances, Hoedts in \cite{hoedt} has extended
\cite{causemaecker1} antichains implementation by using bit sequence
instead of tree reprensentation.


\todo{Discuss impl. specifics etc in chapter Implementation}
\todo{What operations are implemented in those papers ?}
\todo{What domain (of sets) is is used in those papers ?}
\todo{Research other possible related works}

\chapter{Data Structures}

In this section, we will provide formal definitions of the data
structures that we will implement. We recall the notion of binary relations
and important propreties of such relations.
We then define partially ordered set, totally order set and closed set.
Finally we give a formal definition for antichains and pseudo-antichains.

\paragraph{}

The definitions and examples for this section are based on \cite{bohy_phd}.


\section{Binary relations}

\paragraph{}

A binary relation for an arbitrary set $S$ is
a set of pair $R \subseteq S \times S$.
There are five important properties: reflexitivity, transitivity,
symmetry, antisymmetry and total.

\paragraph{}

A relation $R$ on $S$ is said to be:

\begin{itemize}
    \item Reflexive:
    iff $\forall s \in S$ it holds that $(s, s) \in R$
    \item Transitive:
    iff $\forall s_1, s_2, s_3 \in S$,
    if ($s_1, s_2) \in R$ and $(s_2, s_3) \in R$
    then it holds that $(s_1, s_3) \in R$
    \item Symmetric: iff $(s_1, s_2) \in R$ then $(s_2, s_1) \in R$.
    \item Antisymmetric: iff $(s_1, s_2) \in R$
    and $(s_2, s_1) \in R$ then $s_1 = s_2$
    \item Total: iff $\forall s_1, s_2 \in S$ then $(s_1, s_2) \in R$
    or $(s_2, s_1) \in R$\todo{is this Total def correct ?}

\end{itemize}

\paragraph{Orders}

A \textit{partial order} is a binary relation that is \textit{reflexive},
\textit{transitive} and \textit{antisymmetric}. We note a
partial order relation by $R$.
We note $s_1 R  s_2$ to show the belonging of
a binary relation to a partial order, which is equivalent
to $(s_1, s_2) \in \ R$.
A \textit{total order} is a partial order that is \textit{total}.

\section{Partially ordered set}

\paragraph{}

An arbitrary set $S$ associated with a partial order $\preceq$
is called a \textit{partially ordered set} or \textit{poset}.
It is denoted by the pair $\langle S, \preceq \rangle$.

\paragraph{Comparable}

Let $s_1, s_2 \in S$ and $\tuple{S, \preceq}$ a poset.
The two elementes $s_1$ and $s_2$ are called \textit{comparable} if either
$s_1 \preceq s_2$ or $s_2 \preceq s_1$. If neither of those two comparaisons
are correct, then $s_1$ and $s_2$ are called \textit{uncomparable}.


\paragraph{Bounds} Let $\tuple{S, \preceq}$ a partially ordered set.
We denote the \textit{greatest lower bound} of the two elements $s_1, s_2 \in S$
by $s_1 \sqcap s_2 \in S$.
The greatest lower bound is defined as follow:
$s_1 \sqcap s_2 \preceq s_1$,
$s_1 \sqcap s_2 \preceq s_2$ and for all $s' \in S$ we have that
if $s' \preceq s_1$ and $s' \preceq s_2$ then $s' \preceq s_1 \sqcap s_2$.

\todo{Include definition of least upper bound}

\paragraph{Lattices} A \textit{lower semilattice} is a poset
$\tuple{S, \preceq}$ where for all pair of elements $s_1, s_2 \in S$,
we have that the greatest lower bound $s_1 \sqcap s_2$ exists.

\section{Antichains and pseudo-antichains}

\subsection{Closed sets}

\paragraph{}


A closed set is a set $L \subseteq S$
of a lower semilattice $\langle S, \preceq \rangle$
where $\forall l \in L$ we have that $\forall s \in S$ such that
$s \preceq l$, then $s \in L$.

Note that for two closed sets $L_1, L_2 \subseteq S$, we have that
$L_1 \cup L_2$ and $L_1 \cap L_2$ are also closed sets,
but $L_1 \setminus L_2$ does not result necessarily to a closed set.

\paragraph{Maximal/minimal elements} We denote by $\ceil{L}$
the set of maximal elements of a closed set $L$ which
\todo{Meaning of | vs . vs : in set definition ?}
correspond to $\ceil{L} = \{ l \in L | \forall l' \in L :  l \preceq l'
 \Rightarrow l = l' \}$. Alternatively, to represent the set of minimal
 elements, the noation $\floor{L}$ is used which has the following semantic
$\floor{L} = \{ l \in L | \forall l' \in L :  l' \preceq l
 \Rightarrow l = l' \}$.


\paragraph{Closure} A \textit{lower closure} of a set $L$ on $S$
noted $\darrow L$ is the set of all elements of $S$ that are
\textit{smaller or equal} to an element of $L$ i.e.
$\darrow L = \{ s \in S \ | \ \exists l \in L \cdot s \preceq l\}$.
Note that for a closed set $L$ we have that $\darrow L = L$.


\subsection{Antichains}

\paragraph{}

An antichain of a poset $\tuple{S, \preceq}$
is a set $\alpha \subseteq S$ where all element of $\alpha$
are uncomparable with respect to the partial order $\preceq$.
Antichains allow to represent closed set in a more compact way.
For a closed set $L \subseteq S$ we can retrieve all elements of $L$ by using
the antichain $\alpha = \ceil{L}$. With respect
to the definition of the lower closure we have that $\darrow \alpha = L$.

\subsection{Operations on antichains}

\todo{Cite original paper, FJR11 from Bohy' phd}



\begin{proposition}

\ref{antichains_ops}

Let $\alpha_1, \alpha_2 \subseteq S$ two antichains and $s \in S$:

\begin{itemize}
    \item $s \in \darrow \alpha_1$
    iff $\exists a \in \alpha_1$ such that $\preceq a$
    \item $\darrow \alpha_1 \subseteq \darrow \alpha_2$
    iff $\forall a_1 \in \alpha_1,
    \exists a_2 \in \alpha_2$ such that $a_1 \preceq a_2$
    \item $ \darrow \alpha_1 \ \cup \darrow \alpha_2 =
    \darrow \ceil{\alpha_1 \cup \alpha_2}$
    \item $\darrow \alpha_1 \ \cap \darrow \alpha_2 =
    \darrow \ceil{\alpha_1 \sqcap \alpha_2}$

\todo{Give complete definition for interesection}

\end{itemize}

\end{proposition}



% \subsection{Pseudo-antichains}
%
% \paragraph{}
%
% An antichain is a subset of $S$ that allow to represent in a compact way
% a set $L \subseteq S$ that is not necessarily closed.

\chapter{Implementation}

\paragraph{}

Java already provide built-in implementation for \texttt{Set}.
\todo{Includes limitation of Java built-in and different possible solution
for antichains found on stack overflow and others}

\paragraph{}

In this thesis we are more interested in partially ordered sets as
totally ordered sets are already implemented
in\texttt{Java} built-in
\texttt{SortedSet}.

\section{Summary of objectives}


\paragraph{}


The main focus of the thesis is to be able to provide an efficient
implementation of antichains and pseudo-antichains in \texttt{Java}.
The first step is to provide an interface for the different operations that
can be applied to antichains. We then give a description of the implementation.
Antichains provide a way to represent
in a compact way partially ordered set that are closed. Pseudo-antichains
are an extension of antichains and provide a compact way to represent
partially ordered sets. Pseudo-antichains does not specifically require
closed set.

Our goal is to find a way to not keep all the closure all
element of the antichain in memory, but be able to retrieve those elements
or check the belonging of a closure element from the uncomparable elements
of the antichain.

\section{Existing implementation}

\subsection{AaPAL}

Bohy's \textbf{A}ntichain
\textbf{a}nd \textbf{P}seudo-\textbf{A}ntichain \textbf{L}ibrary \cite{aapal}
is an open-source \texttt{C} library for the manipulation
of antichains and pseudo-antichains data structures.


\subsubsection{Antichain representation}

An antichain is represented by a \texttt{struct}, containing as attributes
the size of the antichain, and the incomparable elements of the antichains,
as a list. The list is manipulated using the \texttt{GSList} object
from the \texttt{glib} library. To allow modularity, the type of the elements
is \texttt{void}.

\subsubsection{Operations}

The operations implemented in \texttt{AaPAL}
are described in this section.
An interesting remark is that most of the complexity is given as a paramater
to the functions. For example the function to compare two elements in
an antichain is given as a parameter. It means that the complexity to define
the domain of the antichain, must be implemented in the compare function.

Operations such as creating an antichain,
adding an element to
an antichain, checking emptiness or cloning an antichain are implemented
in \texttt{AaPAL}. In addition to that

create
add elem
clone

interesection
Union

compare 2 antichains

containing element
closure size



\subsection{ABD}

\subsection{Hoedt's ABD modifications}
\todo{Referring to \cite{hoedt}}
\todo{Is actually \cite{hoedt} what we what to do, and if not, what will
be the differences ?}



\section{Difficulties}

\todo{What is the difference beetween domain, univers and set ?}

One of the difficulties is to define the domain of the elements that
the antichains should work on. In \texttt{AaPAL} the all complexity
is implemented in the \texttt{compare\_elements} that must be given
to the library functions. It that case, all the complexity of the
must be implemented by the user to define the domain of the antichains.

\subsection{Tree vs Bitarray representations}


\section{Possible solutions}

In the case of the domain specifications, a good approach could be to
provide an interface/abstract class to the users, to let them provide
their own implementation. In addition to that, usual domain such a
natural numbers or others well known domain used, could be directly implemented
in the library.


\section{New implementation}


\chapter{Conclusion}


\section{Possible extensions}


As we mainly focus on efficiency, it could be interesting to use a \texttt{C}
implementation such as \texttt{AaPAL},
and provide bindings to \texttt{Java}. We could try
this method as an alternative to a pure \texttt{Java} implementation and
compare performances.


\todo{Fill-in bib correctly!}

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
