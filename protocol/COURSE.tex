\documentclass[10pt,a4paper]{article}
% \usepackage{natbib}

\usepackage[utf8]{inputenc}
\usepackage{mathpazo}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{todonotes}

\usepackage[margin=1.5in]{geometry}



\title{INFO-F-514 -     Course Report \\
Secure computation}
\author{Universit√© Libre de Bruxelles \\
\\ Hakim Boulahya}


\begin{document}

\maketitle

\newpage

% \begin{abstract}
% \end{abstract}

\section{Introduction}

In this paper we will propose formal definitions of secure
computation, also refered as secure multiparty computation.
We will also gives known example in the litterature
that are defined following the logical of secure computation.
We will then recall
state of the art techniques and protocols that allow
to resolve secure computations.

\section{Secure computation}

A secure multi-part computation problem, is a problem where a computation,
or a result, must be computed but the input that each party must used
is confidential and not share between all parties. Such problem
can be defined as a function $f(\cdot)$, that takes $n$ parameters.
The idea is to be able to compute the function $f(x_0, .., x_n)$
where the input $x_i$ can only be accessed by the party $i$.
The final results is accessible to everyone.
\todo{cite f(.)}

\section{Problems}

\paragraph{}


There exists multiple problems that used the secure computation definition.
For example the millionaires problem
\cite{yao_protocols_1982}, is the problem that for two millionaires
they both want to know which one of them is the richer, but they
don't want to know the difference. In this problem, the computation
function is the usual comparison $<$, and the inputs are the incomes of
the individuals.


\paragraph{Oblivious Transfer}

Another problem is the Oblivious Transfer introduced by Rabin during
in 1982 \cite{rabin_how_nodate}. The Oblivious Transfer has many application
and has been first introduced has a protocol to resolve the Exchange Of
Secret problem. In the context of secure computation,
The 1-out-of-2 Oblivious Transfer ($OT^1_2$),
an another approach to the original Oblivious Transfer, is the problem
that for a sender and a receiver, one of two message must be sent
from the receiver to the sender. The message receive can be chosen
by the receiver. Two constraints are that the sender must never know
which message has been chosen, and the receiver must not know
the content of the other message.

1-out-of-n Oblivious Transfer ($OT^1_n$) is an extension of $OT^1_2$,
where the sender has $n$ messages to send and the receiver must choose
one of theme. Those two protocols are theorically equivalent
has proven in \cite{goos_equivalence_1988, goos_foundations_1998}.

\section{Original Oblivious Transfer protocol}

The Oblivious Protocol is defined as follow: Alice has
a message to send to Bob.

\section{1-out-of-2 Oblivious Transfer protocol}

On possible protocol for the $OT^1_2$ problem is by using a pair of
key using the RSA protocol, first proposed in \cite{even_randomized_1985}.
Let Alice be the sender and Bob the receiver.
Alice has two messages $m_0,m_1$, and in addition to that
a public RSA key $(e, d, n)$. The protocol is a multi-step
communication between the two parties using the RSA public key
of Alice.

\paragraph{}

The first step is for Alice
to send the public key and two random values, that is
the public key $(e, n)$ and two random values $x_0, x_1$
contains in the domain $[1, n-1]$. Now that Bob has those inputs,
he will generates on his side two other random values.
The first one is the bit $b$ which value is either $0$ or $1$,
and is used to choose which random inputs received from Alice,
that is $x_b$ would be either $x_0$ or $x_1$. The second
generated random value of Bob is a value $k$ in the domain
$[1, n-1]$.

\paragraph{}


The second step is for Bob to return his response. Since
we don't want Alice to know which value has been chosen, Bob
will encrypt the value $x_b$ by blinding it using the random value $k$
that he generated. That is Bob will send to Alice
the value $v = (x_b + k^e) \mod n$.
Upon receival of $v$, Alice will decrypt $v$ two times, by removing
the random values. That is, Alice will have two values $k_0, k_1$
where $k_i = (v - x_i)^d \mod n$.

\paragraph{}

Finally, the last step if for Alice to send back the real message.
Since $v$ was blinded by Bob
with the value $k$, Alice doesn't know which random $x_i$ has been chosen.
By computing the two $k_i$ based on both values, one of them
will be identical to the $k$ value of Bob. The last inputs that
Alice will send to Bob are the two messages $m'_0, m'_1$ where
$m'_i = m_i + k_i$. Upon receival, Bob will have to decrypt
the message with $k$, that is $m_b = m'_b - k$. Since Bob
only has the $k_i$ value associate to his message, he will not be
able to decrypt the other message.

\todo{Give propoer def of RSA public key}





\todo{explain rsa key pair (add a reminder section)}
\todo{OT12 vs OT equivalence (check article that OT12 -> OT but not OT OT12)}
\todo{why second step of Bob we have $k^e$ ?}

\todo{Proof of OT12 et OT equivalement Crepeau page 351 et Event page 640}

\section{Secure computation with $OT^1_2$}



\bibliographystyle{alpha}
\bibliography{COURSE}

\end{document}
